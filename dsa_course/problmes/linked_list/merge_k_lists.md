# Merge K sorted linked lists

## Tags

- recursion
- merge

## Анализ сложности `mergeKLists`

1. **Обозначения**:
   - k — количество списков в `lists`.
   - n — средняя длина списка.

2. **Разделение списков (рекурсия)**:
   - На каждом уровне рекурсии функция делит массив `lists` на две части (O(1) для деления).
   - Глубина рекурсии составляет log(k), так как массив делится пополам.

3. **Слияние списков `mergeTwoLists`**:
   - Для слияния двух списков `mergeTwoLists` требуется O(n), где n — общая длина двух списков.

4. **Слияние всех списков**:
   - На каждом уровне рекурсии:
     - Сливаются k/2 пар списков.
     - Стоимость одного слияния — O(n).
     - Итоговая сложность на уровне: O(k * n / 2).
   - Учитывая log(k) уровней рекурсии, итоговая сложность:
     O(n * k * log(k)).

---

### Анализ сложности `mergeTwoLists`

- Каждое сравнение и перемещение указателей выполняется за O(1).
- Все элементы обрабатываются один раз.
- Итоговая сложность: O(n), где n — сумма длин двух списков.

---

### Итоговая оценка

Сложность всей функции `mergeKLists`:

O(n * k * log(k))

где:
- k — количество списков,
- n — средняя длина каждого списка.

**Пространственная сложность**:
- Стек рекурсии имеет глубину log(k).
- Память: O(log(k)) для хранения рекурсивных вызовов.

